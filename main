# Загрузка библиотек
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv('data.csv', delimiter=';', index_col='data')
df.index = pd.to_datetime(df.index)
print(df)

# Log of percentage change
cov_matrix = df.pct_change().apply(lambda x: np.log(1 + x)).cov()
print(cov_matrix)

corr_matrix = df.pct_change().apply(lambda x: np.log(1 + x)).corr()
print(corr_matrix)

# Randomly weighted portfolio's variance Рандомные веса для портфеля и вывод дисперсии
w = {'TSLA': 0.6, 'FB': 0.4}
port_var = cov_matrix.mul(w, axis=0).mul(w, axis=1).sum().sum()
print(port_var)

# Yearly returns for individual companies Доходы по дням D (M,Y) (месяц, год)
ind_er = df.resample('D').last().pct_change().mean()
print(ind_er)

# Portfolio returns Доходность портфеля
w = [0.6, 0.4]
port_er = (w * ind_er).sum()
print(port_er)

#Дальше основной скрипт

# Volatility is given by the annual standard deviation. We multiply by 250 because there are 250 trading days/year.
# Волатильность определяется годовым стандартным отклонением. Мы умножаем на 250, потому что в году 250 торговых дней.
ann_sd = df.pct_change().apply(lambda x: np.log(1+x)).std().apply(lambda x: x*np.sqrt(250))
print(ann_sd)

assets = pd.concat([ind_er, ann_sd], axis=1) # Creating a table for visualising returns and volatility of assets
assets.columns = ['Returns', 'Volatility']
print(assets)

p_ret = [] # Define an empty array for portfolio returns Определите пустой массив для доходности портфеля
p_vol = [] # Define an empty array for portfolio volatility Определите пустой массив для волатильности портфеля
p_weights = [] # Define an empty array for asset weights Определите пустой массив для весов активов

num_assets = len(df.columns)
num_portfolios = 100

for portfolio in range(num_portfolios):
    weights = np.random.random(num_assets)
    weights = weights/np.sum(weights)
    p_weights.append(weights)
    returns = np.dot(weights, ind_er) # Доходность - это произведение индивидуальной ожидаемой доходности актива и его весов
    p_ret.append(returns)
    var = cov_matrix.mul(weights, axis=0).mul(weights, axis=1).sum().sum()# Portfolio Variance
    sd = np.sqrt(var) # Daily standard deviation Ежедневное стандартное отклонение
    ann_sd = sd*np.sqrt(250) # Annual standard deviation = volatility Годовое стандартное отклонение = волатильность
    p_vol.append(ann_sd)

data = {'Returns':p_ret, 'Volatility':p_vol}

for counter, symbol in enumerate(df.columns.tolist()):
    #print(counter, symbol)
    data[symbol+' weight'] = [w[counter] for w in p_weights]

portfolios  = pd.DataFrame(data)
print(portfolios.head()) # Dataframe of the 10000 portfolios created Фрейм данных из 10000 созданных портфелей

# Plot efficient frontier
portfolios.plot.scatter(x='Volatility', y='Returns', marker='o', s=10, alpha=0.3, grid=True, figsize=[10,10])
plt.show()

# Дальше надо пройтись по границе и найти лучшие решения

min_vol_port = portfolios.iloc[portfolios['Volatility'].idxmin()]
# idxmin() gives us the minimum value in the column specified.
print(min_vol_port)

# plotting the minimum volatility portfolio
plt.subplots(figsize=[10,10])
plt.scatter(portfolios['Volatility'], portfolios['Returns'],marker='o', s=10, alpha=0.3)
plt.scatter(min_vol_port[1], min_vol_port[0], color='r', marker='*', s=500)

plt.show()
